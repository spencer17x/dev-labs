"""分析成功交易的 input data 结构"""

import binascii

# 成功交易的 input data
input_data = "0x519ebb100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000060decc40000019ba23cebba00000000000000000000000000000000000000010703eb89000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000033b2e3c9fd0803ce800000000000000000000000000000000000000000000000295be96e64066972000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00000000000000000000000000000000000000000000028a857425466f800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000696800f90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000696800f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000742494720444f4e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000742494720444f4e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041054ed8e455d658efb277abe012b221a0b1049cef80a5a7fce92dc9fe4e99923b5bcaba1dbf49eebeec735ed827d3fdda68082b666a5089a08fb24dead43009791b00000000000000000000000000000000000000000000000000000000000000"

# 移除 method selector (前10个字符: 0x + 8字符)
data = input_data[10:]

print("Input data 结构分析:")
print("=" * 60)

# 前两个参数是 bytes 的偏移量
offset1 = int(data[0:64], 16)
offset2 = int(data[64:128], 16)

print(f"Bytes1 偏移量: {offset1} (0x{offset1:x})")
print(f"Bytes2 偏移量: {offset2} (0x{offset2:x})")

# 解析 bytes1 (token params)
bytes1_start = offset1 * 2
bytes1_len = int(data[bytes1_start:bytes1_start+64], 16)
bytes1_data = data[bytes1_start+64:bytes1_start+64+bytes1_len*2]

print(f"\nBytes1 长度: {bytes1_len} bytes")
print(f"Bytes1 数据 (hex):\n{bytes1_data}")

# 解析 bytes2 (signature)
bytes2_start = offset2 * 2
bytes2_len = int(data[bytes2_start:bytes2_start+64], 16)
bytes2_data = data[bytes2_start+64:bytes2_start+64+bytes2_len*2]

print(f"\nBytes2 长度: {bytes2_len} bytes")
print(f"Bytes2 数据 (hex): {bytes2_data}")

# 签名是 65 字节 (r: 32, s: 32, v: 1)
if bytes2_len == 65:
    print("\n✅ Bytes2 是一个 ECDSA 签名 (65 bytes)")
    r = bytes2_data[0:64]
    s = bytes2_data[64:128]
    v = bytes2_data[128:130]
    print(f"  r: 0x{r}")
    print(f"  s: 0x{s}")
    print(f"  v: 0x{v} ({int(v, 16)})")

# 尝试解码 bytes1 中的文本
print("\n" + "=" * 60)
print("尝试解析 Bytes1 中的代币信息...")
try:
    raw_bytes = bytes.fromhex(bytes1_data)
    # 找可打印的 ASCII 字符串
    current_str = ""
    for b in raw_bytes:
        if 32 <= b <= 126:
            current_str += chr(b)
        else:
            if len(current_str) >= 3:
                print(f"  发现文本: '{current_str}'")
            current_str = ""
    if len(current_str) >= 3:
        print(f"  发现文本: '{current_str}'")
except Exception as e:
    print(f"解析错误: {e}")

print("\n" + "=" * 60)
print("结论: Four.meme BSC 版本需要服务端签名才能创建代币")
